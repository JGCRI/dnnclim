"""Tools for recording details of a set of model runs

   Typical use will be:
       * Start a new run with a specified configuration: newrun()
       * Get the names of the savefile and outfile arguments to 
         runmodel:  filenames()
       * Record the results of a run: record_rslts()
       * Write all as yet unwritten index records: writeindex()
       * Return a list of indices for a list of input configurations:
         findidx()
"""

import yaml
import os
import numpy as np
import time

class RunRecorder:
    """Structure for keeping and writing records of runs performed"""
    
    def __init__(self, recorddir=None, noclobber=True):
        """Initialize a run recorder

        :param recorddir: Directory to store records in.  
        :param noclobber: If true, refuese to overwrite existing output dir.
                 
        The records stored include a master index of run configurations and the
        checkpoint files generated by tensorflow. If reccorddir is omitted, the
        default is 'runrecords' in the current directory.

        """

        ## In case you're wondering, runs are stored in a dictionary
        ## rather than a list because a dictionary can be written
        ## incrementally to YAML and still produce a valid document.

        self.idx = 0            # Serial index of runs
        self.runs = {}          # dictionary of run data, indexed by serial number
        self.indices = {}       # dictionary of serial numbers, indexed by model spec

        if recorddir is None:
            recorddir = os.path.join(os.getcwd(), 'runrecords')
        else:
            recorddir = os.path.abspath(recorddir) 
        self.recorddir = recorddir
        self.tfsaves = os.path.join(self.recorddir, 'saves')
        self.outputs = os.path.join(self.recorddir, 'outputs')

        if not os.path.exists(self.recorddir):
            os.makedirs(self.recorddir)
            os.makedirs(self.tfsaves)
            os.makedirs(self.outputs)
        elif noclobber:
            raise IOError('Directory {} exists, and noclobber is set.'.format(self.recorddir))

        self.index = open(os.path.join(self.recorddir, 'index.yml'), 'w')
        self.tlast = 0          # time of the last write
        ## TODO: write a comment with the model version at the top of the file.

    def newrun(self, modelspec):
        """Start a record for a new run

        :param modelspec: model specification for the new run
        :return: serial number for the run

        The serial number returned will be used in most of the other functions
        in this class to identify the run.

        """

        modelstr = repr(modelspec)

        ## get next available index
        idx = self.idx
        self.idx += 1

        ## TODO: There's enough going on here that the items in
        ## self.runs could probably use a class of their own.
        self.indices[modelstr] = idx
        self.runs[idx] = {}
        self.runs[idx]['modelspec'] = modelspec
        self.runs[idx]['final-save'] = None # Won't be known until we do the run
        self.runs[idx]['perf'] = None    # Same here.


        runstr = 'save{:06d}'.format(idx) 
        outfilename = runstr + '-out.dat'
        self.runs[idx]['savebase'] = os.path.join(self.tfsaves, runstr)
        self.runs[idx]['outfile'] = os.path.join(self.outputs, outfilename)

        return idx

    def getconfig(self, idx):
        """Get the configuration for a given index."""
        return self.runs[idx]['modelspec'] 
    
    def filenames(self, idxorspec):
        """Get the filename arguments for runmodel()

        :param idxorspec: Index returned by newrun(), or a modelspec
        :return: (savefilebase, outfilename)

        These filenames can be passed directly to the corresponding
        arguments for runmodel().

        """

        if isinstance(idxorspec, int):
            idx = idxorspec
        else:
            [idx] = findidx([idxorspec])

        return (self.runs[idx]['savebase'], self.runs[idx]['outfile'])

    
    def findidx(self, modelspecs):
        """Find the indices for a sequence of model specifications

        :param modelspecs: A sequence of model specification structures. Note
               that it has to be a sequence, even if there is only one of them.
        :return: Sequence of indices corresponding to the input model specs.

        """

        ## obviously, this won't perform gracefully if one or more of
        ## the model configurations isn't in the index.
        return [self.indices[repr(model)] for model in modelspecs]


    def record_rslts(self, idxorspec, perf, finalsave):
        """Record the results of training a given model.

        :param idxorspec: Index returned by newrun(), or a modelspec
        :param perf: Best performance achieved by the model
        :param finalsave: Final save file written by tensorflow

        """

        if isinstance(idxorspec, int):
            idx = idxorspec
        else:
            [idx] = findidx([idxorspec])

        self.runs[idx]['perf'] = perf
        self.runs[idx]['final-save'] = finalsave


    def writeindex(self, dt=0):
        """Write all runs into the index, if sufficient time has elapsed since the last write.

        :param dt: Minimum time since last write, in minutes.  A value of 0 forces an immediate write.
        :return: bool indicating whether the data was written

        This updates the index with data for all runs currently
        available.  The entire index is rewritten, so updates to runs
        that were written in a previous dump will be revised.  In
        other words, you get the current state of the index, not a log
        of its state over time.  If dt>0, then the write will be
        suppressed unless at least that much time has passed since the
        last dump.  This feature can be used to limit the amount of
        disk traffic on systems where disk performance is an issue.

        """

        ## Rewind the file to the beginning
        t = time.time()
        if t-self.tlast >= 60*dt:
            self.index.seek(0) 
            self.index.write(yaml.dump(self.runs))
            self.index.flush()
            self.tlast = t
            return True
        else:
            return False

    def make_sortkey(self):
        """Create a function that can be passed to list.sort() as a sort key.

        Handy for sorting a list of configs from best to worst.  The
        key that is used is the sum reduction of the item stored in
        the configuration's loss function.

        """

        def sortkey(config):
            [idx] = self.findidx([config]) # TODO: really need a class for configs; too easy to forget the brackets.
            return np.sum(self.runs[idx]['perf'])

        return sortkey
            
    def summarize(self, indices):
        """Return summary information for a list of models, specified by their indices.

        :param indices: sequence of model indices to report on
        :return: list of triples of (index, performance, savefile name)

        """

        return [(idx, self.runs[idx]['perf'], self.runs[idx]['final-save']) for idx in indices]
    
